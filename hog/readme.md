## 规则
在Hog游戏中，两名玩家轮流尝试以至少GOAL总分结束回合，其中GOAL默认为100。在每个回合中，当前玩家选择要掷的骰子数量，最多为10个。该玩家的回合得分是骰子结果的总和。但是，掷骰子过多的玩家会冒险：
* Sow Sad。如果任何一个骰子结果是1，则当前玩家的回合得分为1分。

* 示例1：当前玩家掷出7个骰子，其中5个是1。他们的回合得分为1分。
* 示例2：当前玩家掷出4个骰子，全部为3。由于没有发生Sow Sad，他们的回合得分为12分。

在普通的Hog游戏中，这些就是所有规则。为了调味游戏，我们将包括一些特殊规则：
* Pig Tail。选择掷零个骰子的玩家得到2 * abs（tens-ones）+1分；其中tens，ones是对手得分的十位数和个位数。个位数指最右边的数字，十位数指第二个最右边的数字。

* 示例1：
对手得分为46分，当前玩家选择掷零个骰子。2 * abs（4-6）+1 = 5，因此玩家获得5分。

* 示例2：
对手得分为73分，当前玩家选择掷零个骰子。2 * abs（7-3）+1 = 9。

* Square Swine。在玩家获得回合得分后，如果结果得分是完全平方数，则将其得分增加到下一个更高的完全平方数。完全平方数是任何整数n，其中n = d * d，其中d是某个整数。

* 示例1：
一个玩家有12分，掷出3个骰子，总共13分。他们的新得分将是25，但由于25是5的平方，他们的得分增加到6的平方：36。

* 示例2：
一个玩家有12分，掷出3个骰子，总共12分。他们的新得分将是24，这不是完全平方数。

* 示例3：
一个玩家没有得分，掷出5个骰子，但其中一个是1，所以他们的新得分将是1。1是完全平方数，因此他们的得分增加到4。

* 示例4：
一个玩家有80分，掷出10个骰子，但其中有三个是1，所以他们的新得分将是1。81是9的平方，因此他们的新得分是10的平方：100。他们赢得了比赛。

***
## 下载起始文件
要开始，请下载所有项目代码作为 zip 存档。下面是解压缩后存档中看到的所有文件列表。对于项目，您只需要对 hog.py 进行更改。
* `hog.py`：Hog 的起始实现
* `dice.py`：用于制作和掷骰子的函数
* `hog_gui.py`：Hog 的图形用户界面（GUI）（已更新）
* `ucb.py`：CS 61A 的实用函数
* `hog_ui.py`：Hog 的基于文本的用户界面（UI）
* `ok`：CS 61A 自动评分程序
* `tests`：ok 使用的测试目录
* `gui_files`：Web GUI 使用的各种文件的目录

您可能还会注意到除上述文件之外的一些文件，这些文件用于使自动评分程序和部分 GUI 工作。请不要修改除 hog.py 以外的任何文件。

***
## 后勤
该项目价值 25 分，其中 1 分是在 2 月 7 日星期二的检查点日期之前提交 Phase 1。
您将提交以下文件：
hog.py

您不需要修改或提交任何其他文件以完成该项目。要提交项目，请将所需文件提交到相应的 Gradescope 作业。

对于我们要求您完成的函数，可能会提供一些初始代码。如果您不想使用该代码，请随意删除它并从头开始。您也可以根据需要添加新的函数定义。

但是，请不要修改任何其他函数或编辑任何未列出的文件。这样做可能导致您的代码未能通过我们的自动评分器测试。此外，请不要更改任何函数签名（名称、参数顺序或参数数量）。

在整个项目中，您应该测试代码的正确性。经常进行测试是一个好习惯，这样可以轻松地隔离任何问题。但是，您不应该经常测试，以便给自己思考问题的时间。

我们提供了名为 ok 的自动评分器，以帮助您测试代码并跟踪进度。第一次运行自动评分器时，将要求您使用 Web 浏览器使用 Ok 帐户登录。请这样做。每次运行 ok 时，它都会在我们的服务器上备份您的工作和进度。

ok 的主要目的是测试您的实现。
如果您想交互式地测试代码，可以运行 

python3 ok -q [question number] -i，

其中插入适当的问题编号（例如 01）。这将运行该问题的测试，直到您失败的第一个测试，然后让您有机会交互式地测试您编写的函数。
您还可以使用 OK 中的调试打印功能，编写

print("DEBUG:", x)

这将在终端中产生输出，而不会导致 OK 测试失败并带有额外的输出。


## 问题1 Dubugging

调试技巧
如果测试没有通过，那么就是调试的时候了。您可以直接使用 Python 观察函数的行为。首先，启动 Python 解释器并加载 `hog.py` 文件。


python3 -i hog.py

然后，您可以在任意数量的骰子上调用 `roll_dice` 函数。`roll_dice` 函数具有默认参数值，即一个随机的六面骰子函数。因此，以下对 `roll_dice` 的调用模拟了投掷四个公平的六面骰子。


>>> roll_dice(4)

您会发现，由于它模拟了随机骰子掷出的结果，因此前面的表达式每次调用时可能会有不同的结果。您还可以使用测试骰子提前固定骰子的结果。例如，当您知道两次掷骰子会出现 3 和 4 时，掷两次应该得到总共 7 的结果。


>>> fixed_dice = make_test_dice(3, 4) roll_dice(2, fixed_dice)
7

在大多数系统上，您可以通过按上箭头然后按回车键或返回键来再次计算相同的表达式。要计算早期的命令，请反复按上箭头。
如果您发现问题，首先需要更改 hog.py 文件以解决问题，并保存该文件。然后，为了检查您的修复是否有效，您将需要退出 Python 解释器，方法是使用 exit() 或 Ctrl^D，并重新运行解释器以测试您所做的更改。在终端和 Python 解释器中都按上箭头应该可以访问以前的表达式，即使在重新启动 Python 后也是如此。


[默认参数值]:http://composingprograms.com/pages/14-designing-functions.html#default-argument-values
继续调试代码并运行所有的 ok 测试，直到它们全部通过。
还有一个调试提示：要在 ok 测试失败时自动启动交互式解释器，请使用 -i。例如，python3 ok -q 01 -i 将运行问题 1 的测试，然后如果测试失败，将启动加载了 hog.py 的交互式解释器。


## Problem 2

实现 `tail_points` 函数，该函数接受玩家对手当前的分数 opponent_score，并返回当玩家掷骰子 0 次时 Pig Tail 得分的点数。Pig Tail 是一种选择掷骰子 0 次的玩家，其得分为 `2 * abs(tens - ones) + 1`，其中 tens 和 ones 是对手得分的十位数和个位数。个位数是最右边的数字，十位数是第二个从右边开始的数字。

* 例如 1：对手得分为 46 分，当前玩家选择掷骰子 0 次。`2 * abs(4 - 6) + 1 = 5`，因此玩家获得 5 分。

* 例如 2：对手得分为 73 分，当前玩家选择掷骰子 0 次。`2 * abs(7 - 3) + 1 = 9`。

不要假设分数低于 100。编写 tail_points 函数，使其对任何非负分数都能正确工作。

重要提示：您的实现不应使用 str、列表或包含方括号 [] 的内容。测试用例将检查是否使用了这些内容。

在编写任何代码之前，请解锁测试以验证您对问题的理解：python3 ok -q 02 -u Copy ✂️

完成解锁后，开始实现您的解决方案。您可以使用以下命令检查正确性：python3 ok -q 02 Copy ✂️

您还可以通过在终端中运行 python3 -i hog.py 并对各种输入调用 tail_points 来交互式地测试 tail_points。

## Problem 3

问题3（2分）
实现take_turn函数，该函数通过将给定的骰子num_rolls次滚动来返回一次得分的点数。
您对take_turn的实现应调用roll_dice和tail_points而不是重复它们的实现。


## Problem 4
问题4（1分）
添加函数perfect_square和next_perfect_square，以便square_update返回玩家在掷num_rolls后的总得分。您不需要编辑square_update的主体。
平方豚。在玩家获得回合得分后，如果结果得分是完全平方数，则将其得分增加到下一个更高的完全平方数。完全平方数是任何整数n，其中n = d * d，其中d是某个整数。

例1：
玩家得到12分，掷3个骰子得到13分。他们的新得分将是25分，但由于25是5的平方，因此他们的得分增加到6的平方：36。

例2：
玩家得到12分，掷3个骰子得到12分。他们的新得分将是24分，这不是一个完全平方数。

例3：
玩家得到0分，掷5个骰子，但有一个是1，因此他们的新得分将是1。 1是一个完全平方数，因此他们的得分增加到4。

例4：
玩家得到80分，掷10个骰子，但有三个是1，因此他们的新得分将是1。 81是9的平方，因此他们的新得分是10的平方：100。他们赢得了比赛。

## problem 5

实现 play 函数，模拟 Hog 游戏的完整过程。玩家轮流掷骰子，直到其中一名玩家达到目标分数，函数返回两名玩家的最终得分。

为了确定每回合掷多少个骰子，调用当前玩家的策略函数（玩家 0 使用 strategy0，玩家 1 使用 strategy1）。策略是一个函数，给定玩家的分数和对手的分数，返回当前玩家在这回合中将掷出的骰子数。一个示例策略是`always_roll_5`，它出现在 play 函数上方。

为了确定玩家在进行一轮后的得分，调用 update 函数。update 函数需要传入要掷出的骰子数、当前玩家的分数、对手的分数和模拟掷骰子所使用的骰子函数。它返回当前玩家进行一轮后的得分。两个 update 函数的示例是 `simple_update `和 `square_update`。

如果一名玩家在他们进行一轮后达到了目标分数，即在应用所有适用规则后，游戏结束。play 将返回两名玩家的最终总分，其中玩家 0 的得分排在第一位，玩家 1 的得分排在第二位。

一些 play 的示例调用是：
* `play(always_roll_5, always_roll_5, simple_update)` 模拟两名玩家每回合都掷出 5 个骰子，只使用 Sow Sad 和 Pig Tail 规则。
* `play(always_roll_5, always_roll_5, square_update) `模拟两名玩家每回合都掷出 5 个骰子，使用 Square Swine 规则和 Sow Sad 和 Pig Tail 规则（即所有规则）。

重要提示：为了使用户界面正常工作，应在每回合中仅调用一次策略函数。只有在玩家 0 的回合时才调用 strategy0，在玩家 1 的回合时才调用 strategy1。

提示：
* 如果当前玩家是谁，下一个玩家就是 1-who。
* 要调用 `play(always_roll_5, always_roll_5, square_update) 并`打印出每个回合发生的情况，请从终端运行 `python3 hog_ui.py`。


*** 
***
***
***
***
# 阶段2 策略
阶段2：策略
在此阶段，您将尝试改进始终掷出五个骰子的基本策略的方法。 策略是一个函数，它需要两个参数：当前玩家的得分和对手的得分。 它返回玩家将掷出的骰子数，可以是0到10（包括0和10）。

## 问题6 
实现 `always_roll`，这是一个高阶函数，它需要一个骰子数`n`并返回始终掷出`n`个骰子的策略。 因此，`always_roll（5）`等同于 `always_roll_5`。

## 问题7
一种策略只有固定数量的可能参数值。在一个到100的游戏中，有100个可能的`score`（0-99）和100个可能的`opponent_score`（0-99），共有10,000种可能的参数组合。实现 `is_always_roll` 函数，该函数接受一个策略并返回该策略是否始终为每个可能的参数组合掷相同数量的骰子。

## 问题8
实现 `make_averaged`，它是一个高阶函数，它接受一个函数` original_function` 作为参数。

`make_averaged` 的返回值是一个函数，它接受与 `original_function `相同数量的参数。当我们对这个返回的函数传入参数调用时，它将返回重复调用传入参数的 `original_function` 的平均值。

具体来说，这个函数应该总共调用 `total_samples` 次 `original_function`，并返回这些调用结果的平均值。

**重要提示**：为了实现这个函数，你需要使用 Python 的一个新语法。我们想要编写一个接受任意数量参数的函数，然后使用这些参数调用另一个函数。这个语法如下：

不要为函数列出形式参数，而是写 `*args`，表示传递给函数的所有参数。然后我们可以通过将这些 `*args `传递到另一个函数中来使用相同的参数调用另一个函数。例如：

``` python
>>> def printed(f):
...     def print_and_return(*args):
...         result = f(*args)
...         print('Result:', result)
...         return result
...     return print_and_return
>>> printed_pow = printed(pow)
>>> printed_pow(2, 8)
Result: 256
256
>>> printed_abs = printed(abs)
>>> printed_abs(-10)
Result: 10
10
```
在这里，我们可以通过 `*args` 语法将任意数量的参数传递给` print_and_return`。我们还可以在 `print_and_return` 函数内部使用 `*args` 来使用相同的参数调用另一个函数。

## 问题9
实现 `max_scoring_num_rolls` 函数，通过运行实验来确定在一个回合中掷骰子的次数（从1到10），以获得最大平均分数。你的实现应该使用 `make_averaged `和 `roll_dice` 函数。

如果两个掷骰子次数的平均分数相同，则返回较小的数字。例如，如果3和6都获得了最大平均分数，则返回3。

在解锁测试之前，阅读本问题中的 doctest 和示例可能会对你有所帮助。

**重要提示**：为了通过我们的所有测试，请确保你测试的骰子点数从1开始逐步增加到10，而不是从10到1。

## 运行测试
提供的 `run_experiments` 函数调用 `max_scoring_num_rolls(six_sided) `并打印结果。你可能会发现，使用六面骰子投掷6个骰子可以最大化` roll_dice` 的结果。要调用此函数并查看结果，请使用 `-r` 标志运行` hog.py`：

python3 hog.py -r

此外，`run_experiments` 比较各种策略与 `always_roll(6)`。您可以随意更改` run_experiments `的实现。请注意，在下两个问题中实现` tail_strategy `和 `square_strategy` 后，使用这些策略进行实验将不会有准确的结果。

一些实验可能需要一分钟的时间才能运行。您可以始终减少调用 `make_averaged `的试验次数以加速实验。
运行实验不会影响您在项目中的得分。


## 问题10
问题10（2分）
一种策略可以尝试利用*Pig Tail*规则，即在最有利的情况下滚动0。实现`tail_strategy`函数，如果滚动0可以获得至少threshold分，则返回0，否则返回`num_rolls`。此策略不应考虑Square Swine规则。
> 提示：您可以使用在问题2中定义的`tail_points`函数。


## 问题11

更好的策略将充分利用*Pig Tail*和*Square Swine*的组合。即使只有少量的pig tail点数也可以带来巨大的收益。例如，如果一个玩家有31分，对手有42分，掷出0会将他们带到36分，这是一个完美的平方数，因此他们将以49分结束回合：获得49-31=18分！

当掷出0会导致得分至少比玩家回合开始时的得分高threshold分时，`square_strategy`函数返回0。
 
> 提示：您可以使用`square_update`函数。

你应该会发现运行 `python3 hog.py -r `现在会显示出方块策略的胜率接近62%。

## 问题 12

实现`final_strategy`，结合这些想法和任何其他想法，以实现对基线策略的高胜率。一些建议：

* 如果您知道目标得分（默认为100），则得分超过目标没有任何好处。检查是否可以通过掷0、1或2个骰子获胜。如果您领先，您可能会决定冒更少的风险。

* 不要使用阈值，每当掷出0比掷出6平均得分更高时，就掷出0。